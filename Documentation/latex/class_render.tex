\hypertarget{class_render}{
\section{Render Class Reference}
\label{class_render}\index{Render@{Render}}
}


manages visulisation of simulation data generated by the sphSolver  




{\ttfamily \#include $<$Render.h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_render_a8610cc11739ef679b5935dd819021351}{Render} ()
\begin{DoxyCompactList}\small\item\em ctor \item\end{DoxyCompactList}\item 
void \hyperlink{class_render_a52ff4b4560ad5ef64c8babfc2132e7c0}{initialiseRender} (\hyperlink{class_environment_and_rigid_body}{EnvironmentAndRigidBody} $\ast$\_\-environment)
\begin{DoxyCompactList}\small\item\em initialises the shaders and member variables of the class required to view the simulation data \item\end{DoxyCompactList}\item 
void \hyperlink{class_render_abff096b6a70647c4e22272f51df53417}{draw} (\hyperlink{class_environment_and_rigid_body}{EnvironmentAndRigidBody} $\ast$\_\-environment, \hyperlink{class_s_p_h_solver}{SPHSolver} $\ast$\_\-solver, ngl::TransformStack \_\-transformStack, ngl::Camera $\ast$\_\-cam)
\begin{DoxyCompactList}\small\item\em draws the simulation data on the OpenGL Window \item\end{DoxyCompactList}\item 
void \hyperlink{class_render_adee537ebd2b8e1e06163d8021d7f0e67}{updateProjection} (ngl::Camera $\ast$\_\-cam)
\begin{DoxyCompactList}\small\item\em updates the projection matrix for the shaders when the glWindow is resized \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
ngl::BBox $\ast$ \hyperlink{class_render_a5e571da11a215f0eee9b0f44f2a77fb4}{m\_\-bbox}
\begin{DoxyCompactList}\small\item\em pointer to ngl/BBox Class \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
manages visulisation of simulation data generated by the sphSolver 

Definition at line 21 of file Render.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_render_a8610cc11739ef679b5935dd819021351}{
\index{Render@{Render}!Render@{Render}}
\index{Render@{Render}!Render@{Render}}
\subsubsection[{Render}]{\setlength{\rightskip}{0pt plus 5cm}Render::Render ()}}
\label{class_render_a8610cc11739ef679b5935dd819021351}


ctor 



Definition at line 5 of file Render.cpp.




\begin{DoxyCode}
6 {
7 }
\end{DoxyCode}




\subsection{Member Function Documentation}
\hypertarget{class_render_abff096b6a70647c4e22272f51df53417}{
\index{Render@{Render}!draw@{draw}}
\index{draw@{draw}!Render@{Render}}
\subsubsection[{draw}]{\setlength{\rightskip}{0pt plus 5cm}void Render::draw ({\bf EnvironmentAndRigidBody} $\ast$ {\em \_\-environment}, \/  {\bf SPHSolver} $\ast$ {\em \_\-solver}, \/  ngl::TransformStack {\em \_\-transformStack}, \/  ngl::Camera $\ast$ {\em \_\-cam})}}
\label{class_render_abff096b6a70647c4e22272f51df53417}


draws the simulation data on the OpenGL Window 


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em \_\-environment}]pointer to \hyperlink{class_environment_and_rigid_body}{EnvironmentAndRigidBody} Class \item[\mbox{$\leftarrow$} {\em \_\-solver}]pointer to \hyperlink{class_s_p_h_solver}{SPHSolver} Class \item[\mbox{$\leftarrow$} {\em \_\-transformStack}]transformation stack \item[\mbox{$\leftarrow$} {\em \_\-cam}]pointer to ngl/Camera Class \end{DoxyParams}


Definition at line 50 of file Render.cpp.



References EnvironmentAndRigidBody::getBoundaryColour(), SPHSolver::getDrawFluidParticles(), SPHSolver::getFluidParticleList(), EnvironmentAndRigidBody::getObstacleEnabled(), EnvironmentAndRigidBody::getRBDSphereList(), SPHSolver::getVisualizationType(), and m\_\-bbox.




\begin{DoxyCode}
51 {
52 //    std::cout << "Enters the Render" << std::endl;
53     std::string _shadername;
54     std::vector<FluidParticle> _fluidParticleList;
55     std::vector<Particle> _rbdSphereList;
56     ngl::VBOPrimitives* prim = ngl::VBOPrimitives::instance();
57 
58     ngl::ShaderManager *shader=ngl::ShaderManager::instance();
59 
60     /*--- Drawing the Boundary Box -----------*/
61     (*shader)["ConstantShading"]->use();
62     shader->setShaderParam4f("ConstantShading", "inColor", _environment->
      getBoundaryColour().m_r, _environment->getBoundaryColour().m_g, _environment->
      getBoundaryColour().m_b ,1);
63     shader->setShaderParamFromMatrix("ConstantShading","ViewMatrix",_cam->getMode
      lView());
64     _transformStack.loadGlobalAndCurrentMatrixToShader("ConstantShading","ModelMa
      trix");
65             m_bbox->draw();
66 
67 
68     _fluidParticleList = _solver->getFluidParticleList();
69     _rbdSphereList = _environment->getRBDSphereList();
70 
71     /*---Checking if the user wants to visualize the fluid particles------*/
72     if (_solver->getDrawFluidParticles())
73     {
74         if (_solver->getVisualizationType() == "3DShading")
75         {
76             (*shader)["3DShading"]->use();
77             _shadername = "3DShading";
78             shader->setShaderParamFromMatrix(_shadername,"ViewMatrix",_cam->getMo
      delView());
79         }
80         if (_solver->getVisualizationType() == "ConstantShading")
81         {
82              (*shader)["ConstantShading"]->use();
83             _shadername = "ConstantShading";
84             shader->setShaderParamFromMatrix(_shadername,"ViewMatrix",_cam->getMo
      delView());
85         }
86 
87         /*--- Drawing the fluid particles--------*/
88         _transformStack.pushTransform();
89         {
90             for (int i = 0;i<_fluidParticleList.size();++i)
91             {
92                 ngl::Vector _position = _fluidParticleList[i].getCurrentPosition(
      );
93                 ngl::Real _scale = _fluidParticleList[i].getDrawRadius();
94                 ngl::Colour _colour = _fluidParticleList[i].getParticleColour();
95                 _transformStack.getCurrentTransform().setPosition(_position);
96                 _transformStack.getCurrentTransform().setScale(_scale,_scale,_sca
      le);
97                 shader->setShaderParam4f(_shadername, "inColor", _colour.m_r,_col
      our.m_g,_colour.m_b,1.0);
98                 shader->setShaderParamFromMatrix(_shadername,"ModelMatrix", _tran
      sformStack.getCurrAndGlobal().getMatrix());
99                 prim->draw("particle");
100             }
101 
102         }
103         _transformStack.popTransform();
104     }
105     /*---Checking are obstacles enabled or not------*/
106     if (_environment->getObstacleEnabled())
107     {
108 
109     (*shader)["3DShading"]->use();
110     shader->setShaderParamFromMatrix("3DShading","ViewMatrix",_cam->getModelView(
      ));
111 
112         /*--- Drawing the RBD spheres------*/
113         _transformStack.pushTransform();
114         {
115             for (int i = 0;i<_rbdSphereList.size();++i)
116             {
117                 ngl::Vector _position = _rbdSphereList[i].getCurrentPosition();
118                 ngl::Real _scale = _rbdSphereList[i].getDrawRadius();
119                 ngl::Colour _colour = _rbdSphereList[i].getParticleColour();
120                 _transformStack.getCurrentTransform().setPosition(_position);
121                 _transformStack.getCurrentTransform().setScale(_scale,_scale,_sca
      le);
122                 shader->setShaderParam4f("3DShading", "inColor", _colour.m_r,_col
      our.m_g,_colour.m_b,1.0);
123                 shader->setShaderParamFromMatrix("3DShading","ModelMatrix", _tran
      sformStack.getCurrAndGlobal().getMatrix());
124                 prim->draw("particle");
125             }
126         }
127         _transformStack.popTransform();
128     }
129 }
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=190pt]{class_render_abff096b6a70647c4e22272f51df53417_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=128pt]{class_render_abff096b6a70647c4e22272f51df53417_icgraph}
\end{center}
\end{figure}


\hypertarget{class_render_a52ff4b4560ad5ef64c8babfc2132e7c0}{
\index{Render@{Render}!initialiseRender@{initialiseRender}}
\index{initialiseRender@{initialiseRender}!Render@{Render}}
\subsubsection[{initialiseRender}]{\setlength{\rightskip}{0pt plus 5cm}void Render::initialiseRender ({\bf EnvironmentAndRigidBody} $\ast$ {\em \_\-environment})}}
\label{class_render_a52ff4b4560ad5ef64c8babfc2132e7c0}


initialises the shaders and member variables of the class required to view the simulation data 


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em \_\-environment}]pointer to \hyperlink{class_environment_and_rigid_body}{EnvironmentAndRigidBody} Class \end{DoxyParams}


Definition at line 8 of file Render.cpp.



References EnvironmentAndRigidBody::getBBox(), and m\_\-bbox.




\begin{DoxyCode}
9 {
10 
11     m_bbox = new ngl::BBox(_environment->getBBox()->center(),_environment->
      getBBox()->width(),_environment->getBBox()->height(),_environment->getBBox()->dep
      th());
12     ngl::VBOPrimitives *prim =  ngl::VBOPrimitives::instance();
13     prim->createVBOSphere("particle",1,32);
14 
15     ngl::ShaderManager *shader=ngl::ShaderManager::instance();
16 
17     shader->createShaderProgram("3DShading");
18 
19     shader->attachShader("3DShadingVertex",ngl::VERTEX);
20     shader->attachShader("3DShadingFragment",ngl::FRAGMENT);
21     shader->loadShaderSource("3DShadingVertex","shaders/Basic.vs");
22     shader->loadShaderSource("3DShadingFragment","shaders/Basic.fs");
23 
24     shader->compileShader("3DShadingVertex");
25     shader->compileShader("3DShadingFragment");
26     shader->attachShaderToProgram("3DShading","3DShadingVertex");
27     shader->attachShaderToProgram("3DShading","3DShadingFragment");
28     shader->bindAttribute( "3DShading", 0, "inVertex");
29     shader->bindAttribute( "3DShading", 1, "perVColor");
30     shader->linkProgramObject("3DShading");
31     shader->use("3DShading");
32 
33     shader->createShaderProgram("ConstantShading");
34 
35     shader->attachShader("ConstantShadingVertex",ngl::VERTEX);
36     shader->attachShader("ConstantShadingFragment",ngl::FRAGMENT);
37     shader->loadShaderSource("ConstantShadingVertex","shaders/Colour.vs");
38     shader->loadShaderSource("ConstantShadingFragment","shaders/Colour.fs");
39 
40     shader->compileShader("ConstantShadingVertex");
41     shader->compileShader("ConstantShadingFragment");
42     shader->attachShaderToProgram("ConstantShading","ConstantShadingVertex");
43     shader->attachShaderToProgram("ConstantShading","ConstantShadingFragment");
44     shader->bindAttribute( "ConstantShading", 0, "inVertex");
45     shader->bindAttribute( "ConstantShading", 1, "perVColor");
46     shader->linkProgramObject("ConstantShading");
47     shader->use("ConstantShading");
48 }
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=187pt]{class_render_a52ff4b4560ad5ef64c8babfc2132e7c0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=159pt]{class_render_a52ff4b4560ad5ef64c8babfc2132e7c0_icgraph}
\end{center}
\end{figure}


\hypertarget{class_render_adee537ebd2b8e1e06163d8021d7f0e67}{
\index{Render@{Render}!updateProjection@{updateProjection}}
\index{updateProjection@{updateProjection}!Render@{Render}}
\subsubsection[{updateProjection}]{\setlength{\rightskip}{0pt plus 5cm}void Render::updateProjection (ngl::Camera $\ast$ {\em \_\-cam})}}
\label{class_render_adee537ebd2b8e1e06163d8021d7f0e67}


updates the projection matrix for the shaders when the glWindow is resized 


\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em \_\-cam}]pointer to ngl/Camera Class \end{DoxyParams}


Definition at line 131 of file Render.cpp.




\begin{DoxyCode}
132 {
133     ngl::ShaderManager *shader=ngl::ShaderManager::instance();
134     (*shader)["3DShading"]->use();
135           shader->setShaderParamFromMatrix("3DShading","projectionMatrix",_cam->g
      etProjection());
136     (*shader)["ConstantShading"]->use();
137           shader->setShaderParamFromMatrix("ConstantShading","projectionMatrix",_
      cam->getProjection());
138 }
\end{DoxyCode}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=157pt]{class_render_adee537ebd2b8e1e06163d8021d7f0e67_icgraph}
\end{center}
\end{figure}




\subsection{Member Data Documentation}
\hypertarget{class_render_a5e571da11a215f0eee9b0f44f2a77fb4}{
\index{Render@{Render}!m\_\-bbox@{m\_\-bbox}}
\index{m\_\-bbox@{m\_\-bbox}!Render@{Render}}
\subsubsection[{m\_\-bbox}]{\setlength{\rightskip}{0pt plus 5cm}ngl::BBox$\ast$ {\bf Render::m\_\-bbox}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{class_render_a5e571da11a215f0eee9b0f44f2a77fb4}


pointer to ngl/BBox Class 



Definition at line 45 of file Render.h.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{_render_8h}{Render.h}\item 
src/\hyperlink{_render_8cpp}{Render.cpp}\end{DoxyCompactItemize}
